:PROPERTIES:
:ID:       d3309005-8d35-4421-8f3d-60ab14e1f2eb
:LAST_MODIFIED: [2023-10-30 Mon 07:55]
:END:
#+title: Dijkstra's algorithm implementation in Python
#+hugo_custom_front_matter: :slug "d3309005-8d35-4421-8f3d-60ab14e1f2eb"
#+author: Cash Prokop-Weaver
#+date: [2022-12-21 Wed 12:19]
#+filetags: :concept:

An [[id:ef37e8fc-651f-4577-8a68-3bdb0c919928][Implementation]] of [[id:668cbbcc-170b-42c8-b92b-75f6868a0138][Dijkstra's algorithm]] in [[id:27b0e33a-6754-40b8-99d8-46650e8626aa][Python]].

#+begin_src python :results output
from queue import PriorityQueue
import math
from typing import TypeVar, Generic, Optional, Any
from dataclasses import dataclass, field
from itertools import count
from collections.abc import Mapping

T = TypeVar('T')
VertexId = int
EdgeWeight = float

@dataclass(order=True)
class PrioritizedItem:
    priority: float
    item: Any = field(compare = False)

@dataclass
class Vertex(Generic[T]):
    value: T
    id: VertexId = field(default_factory=count().__next__)
AdjacencyList = Mapping[VertexId, Mapping[VertexId, EdgeWeight]]

def dijkstra_single_pair_shortest_path(source_id: VertexId, target_id: VertexId, graph: AdjacencyList) -> Optional[list[VertexId]]:
    """Return shortest path between SOURCE_ID and TARGET_ID within GRAPH using Dijkstra's."""

    previouses = {}
    distances = {}
    visited = set()
    min_queue = PriorityQueue()
    min_queue.add(PrioritizedItem(priority=0, item=source_id))

    while not min_queue.empty():
        edge_weight, parent_id = min_queue.get()

        if parent_id == target_id:
            break

        for child_id, edge_weight in [(child_id, graph[parent_id][child_id]) for child_id in graph[parent_id] if child_id not in visited]:
            if to_id not in distances:
                distances[to_id] = math.inf
                #min_queue.put((math.inf, (source_id, child_id)))
            distance_through_parent = distances[parent_id] + edge_weight
            if distance_through_parent < distance[child_id]:
                distances[child_id] = distance_through_parent
                previouses[child_id] = parent_id
                min_queue.

    if target_id not in previouses:
        return None

    # TODO: Refactor as function?
    shortest_path = []
    current_id = target_id
    while current_id != source_id:
        shortest_path.append(current_id)
        current_id = previouses[current_id]
    shortest_path.append(source_id)
    return reversed(shortest_path)

a = Vertex(value='a')
b = Vertex(value='b')
c = Vertex(value='c')
d = Vertex(value='d')
e = Vertex(value='e')
f = Vertex(value='f')
adjacency_list = {
    a.id: {b.id: 3, c.id: 5},
    b.id: {c.id: 1},
    c.id: {d.id: 2, e.id: 5},
    d.id: {f.id: 10},
    e.id: {f.id: 1},
}
print(dijkstra_single_pair_shortest_path(a.id, f.id, adjacency_list), 'should be [0, 1, 2, 4, 5]')
print(dijkstra_single_pair_shortest_path(b.id, a.id, adjacency_list), 'should be None')
#+end_src

#+RESULTS:
: None should be [0, 1, 2, 4, 5]
: None should be None

* Flashcards :noexport:
** Implement :fc:implement:
:PROPERTIES:
:CREATED: [2022-12-21 Wed 12:19]
:FC_CREATED: 2022-12-21T20:20:16Z
:FC_TYPE:  normal
:ID:       0e0e3ebf-4d1e-43a1-bbf9-ff5bf274b83e
:END:
:REVIEW_DATA:
| position | ease | box | interval | due                  |
|----------+------+-----+----------+----------------------|
| front    | 2.50 |   3 |     6.00 | 2023-08-02T14:06:39Z |
:END:

Implement [[id:668cbbcc-170b-42c8-b92b-75f6868a0138][Dijkstra's algorithm]] in [[id:27b0e33a-6754-40b8-99d8-46650e8626aa][Python]] to solve the [[id:477fb65f-3351-4154-a270-08c58cdcaf88][Single-pair shortest path problem]]

*** Back
[[id:d3309005-8d35-4421-8f3d-60ab14e1f2eb][Dijkstra's algorithm implementation in Python]]
*** Source
** Implement :fc:implement:
:PROPERTIES:
:CREATED: [2022-12-21 Wed 12:19]
:FC_CREATED: 2022-12-21T20:20:16Z
:FC_TYPE:  normal
:ID:       c6821c57-cfdf-49a8-b981-820c75c94373
:END:
:REVIEW_DATA:
| position | ease | box | interval | due                  |
|----------+------+-----+----------+----------------------|
| front    | 2.65 |   6 |   114.79 | 2023-10-08T08:42:01Z |
:END:

Implement [[id:668cbbcc-170b-42c8-b92b-75f6868a0138][Dijkstra's algorithm]] in [[id:27b0e33a-6754-40b8-99d8-46650e8626aa][Python]] to solve the [[id:9d301c65-05c3-44f8-9660-90e0e963e6aa][Single-source shortest path problem]]

*** Back
[[id:d3309005-8d35-4421-8f3d-60ab14e1f2eb][Dijkstra's algorithm implementation in Python]]
*** Source
* Bibliography
#+print_bibliography:
